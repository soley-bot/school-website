-- Drop existing triggers first
drop trigger if exists handle_term_banner_updated_at on public.term_banner;
drop trigger if exists handle_upcoming_events_updated_at on public.upcoming_events;
drop trigger if exists handle_facilities_updated_at on public.facilities;

-- Drop existing policies
drop policy if exists "Enable read access for all users" on public.term_banner;
drop policy if exists "Enable insert for authenticated users only" on public.term_banner;
drop policy if exists "Enable update for authenticated users only" on public.term_banner;
drop policy if exists "Enable delete for authenticated users only" on public.term_banner;

drop policy if exists "Enable read access for all users" on public.upcoming_events;
drop policy if exists "Enable insert for authenticated users only" on public.upcoming_events;
drop policy if exists "Enable update for authenticated users only" on public.upcoming_events;
drop policy if exists "Enable delete for authenticated users only" on public.upcoming_events;

drop policy if exists "Enable read access for all users" on public.facilities;
drop policy if exists "Enable insert for authenticated users only" on public.facilities;
drop policy if exists "Enable update for authenticated users only" on public.facilities;
drop policy if exists "Enable delete for authenticated users only" on public.facilities;

-- Drop all storage policies
drop policy if exists "Give public access to images" on storage.objects;
drop policy if exists "Enable image upload for authenticated users only" on storage.objects;
drop policy if exists "Enable image update for authenticated users only" on storage.objects;
drop policy if exists "Enable image delete for authenticated users only" on storage.objects;
drop policy if exists "Public Access" on storage.objects;
drop policy if exists "Authenticated users can upload facilities images" on storage.objects;
drop policy if exists "Authenticated users can update facilities images" on storage.objects;
drop policy if exists "Authenticated users can delete facilities images" on storage.objects;
drop policy if exists "Authenticated users can upload events images" on storage.objects;
drop policy if exists "Authenticated users can update events images" on storage.objects;
drop policy if exists "Authenticated users can delete events images" on storage.objects;
drop policy if exists "facilities_public_select" on storage.objects;
drop policy if exists "facilities_auth_insert" on storage.objects;
drop policy if exists "facilities_auth_update" on storage.objects;
drop policy if exists "facilities_auth_delete" on storage.objects;
drop policy if exists "events_public_select" on storage.objects;
drop policy if exists "events_auth_insert" on storage.objects;
drop policy if exists "events_auth_update" on storage.objects;
drop policy if exists "events_auth_delete" on storage.objects;

-- Create tables
create table if not exists public.term_banner (
    id bigint generated by default as identity primary key,
    text text not null,
    is_active boolean default false not null,
    created_at timestamp with time zone default timezone('utc'::text, now()) not null,
    updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

create table if not exists public.upcoming_events (
    id bigint generated by default as identity primary key,
    title text not null,
    description text not null,
    date timestamp with time zone not null,
    image_url text,
    created_at timestamp with time zone default timezone('utc'::text, now()) not null,
    updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

create table if not exists public.facilities (
    id bigint generated by default as identity primary key,
    title text not null,
    description text not null,
    image_url text,
    created_at timestamp with time zone default timezone('utc'::text, now()) not null,
    updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Enable Row Level Security
alter table public.term_banner enable row level security;
alter table public.upcoming_events enable row level security;
alter table public.facilities enable row level security;

-- Create policies for term_banner
create policy "Enable read access for all users" on public.term_banner
    for select using (true);

create policy "Enable insert for authenticated users only" on public.term_banner
    for insert with check (auth.role() = 'authenticated');

create policy "Enable update for authenticated users only" on public.term_banner
    for update using (auth.role() = 'authenticated');

create policy "Enable delete for authenticated users only" on public.term_banner
    for delete using (auth.role() = 'authenticated');

-- Create policies for upcoming_events
create policy "Enable read access for all users" on public.upcoming_events
    for select using (true);

create policy "Enable insert for authenticated users only" on public.upcoming_events
    for insert with check (auth.role() = 'authenticated');

create policy "Enable update for authenticated users only" on public.upcoming_events
    for update using (auth.role() = 'authenticated');

create policy "Enable delete for authenticated users only" on public.upcoming_events
    for delete using (auth.role() = 'authenticated');

-- Create policies for facilities
create policy "Enable read access for all users" on public.facilities
    for select using (true);

create policy "Enable insert for authenticated users only" on public.facilities
    for insert with check (auth.role() = 'authenticated');

create policy "Enable update for authenticated users only" on public.facilities
    for update using (auth.role() = 'authenticated');

create policy "Enable delete for authenticated users only" on public.facilities
    for delete using (auth.role() = 'authenticated');

-- Delete existing objects in the buckets (optional, comment out if you want to preserve existing files)
delete from storage.objects where bucket_id = 'facilities';
delete from storage.objects where bucket_id = 'events';

-- Drop existing buckets
delete from storage.buckets where id = 'facilities';
delete from storage.buckets where id = 'events';

-- Create storage buckets with public access
insert into storage.buckets (id, name, public)
values ('facilities', 'facilities', true);

insert into storage.buckets (id, name, public)
values ('events', 'events', true);

-- Set up storage policies for facilities bucket
create policy "facilities_public_select"
on storage.objects for select
using ( bucket_id = 'facilities' );

create policy "facilities_auth_insert"
on storage.objects for insert
with check (
    bucket_id = 'facilities'
    and auth.role() = 'authenticated'
);

create policy "facilities_auth_update"
on storage.objects for update
using (
    bucket_id = 'facilities'
    and auth.role() = 'authenticated'
);

create policy "facilities_auth_delete"
on storage.objects for delete
using (
    bucket_id = 'facilities'
    and auth.role() = 'authenticated'
);

-- Set up storage policies for events bucket
create policy "events_public_select"
on storage.objects for select
using ( bucket_id = 'events' );

create policy "events_auth_insert"
on storage.objects for insert
with check (
    bucket_id = 'events'
    and auth.role() = 'authenticated'
);

create policy "events_auth_update"
on storage.objects for update
using (
    bucket_id = 'events'
    and auth.role() = 'authenticated'
);

create policy "events_auth_delete"
on storage.objects for delete
using (
    bucket_id = 'events'
    and auth.role() = 'authenticated'
);

-- Create trigger function for updated_at
create or replace function handle_updated_at()
returns trigger as $$
begin
    new.updated_at = timezone('utc'::text, now());
    return new;
end;
$$ language plpgsql;

-- Create triggers
create trigger handle_term_banner_updated_at
    before update on public.term_banner
    for each row
    execute function handle_updated_at();

create trigger handle_upcoming_events_updated_at
    before update on public.upcoming_events
    for each row
    execute function handle_updated_at();

create trigger handle_facilities_updated_at
    before update on public.facilities
    for each row
    execute function handle_updated_at();

-- Add public read access policies for the frontend
create policy "Allow public to read term_banner"
    on public.term_banner for select to anon using (true);

create policy "Allow public to read upcoming_events"
    on public.upcoming_events for select to anon using (true);

create policy "Allow public to read facilities"
    on public.facilities for select to anon using (true);
